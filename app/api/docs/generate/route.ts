import { generateText } from 'ai';
import { anthropic } from '@ai-sdk/anthropic';
import { nanoid } from 'nanoid';
import { promises as fs } from 'fs';
import path from 'path';
import type { DocGenerateRequest, DocEvent, DocNode, DocTreeState } from '@/lib/doc-agent/types';
import { DEFAULT_EXCLUDE_PATTERNS } from '@/lib/doc-agent/types';
import {
    scanDirectory,
    parsePatterns,
    distributeFilesToSubagents,
    generateFileTree,
} from '@/lib/doc-agent/file-scanner';
import {
    DOC_AGENT_SYSTEM_PROMPT,
    buildFileDocPrompt,
    PROJECT_SUMMARY_PROMPT,
    buildProjectSummaryPrompt,
} from '@/lib/doc-agent/doc-prompt';

// SSE encoder
function encodeSSE(event: DocEvent): string {
    return `data: ${JSON.stringify(event)}\n\n`;
}

// build final markdown from docs
function buildMarkdown(
    projectSummary: string,
    fileDocs: Array<{ path: string; doc: string }>,
    fileTree: string
): string {
    const timestamp = new Date().toISOString();

    let md = `# Codebase Documentation

> Generated: ${timestamp}

${projectSummary}

---

## File Tree

\`\`\`
${fileTree}
\`\`\`

---

## File Documentation

`;

    for (const { path: filePath, doc } of fileDocs) {
        md += `### \`${filePath}\`

${doc}

---

`;
    }

    md += `
---

*Generated by Doc Agent*
`;

    return md;
}

export async function POST(req: Request) {
    const body: DocGenerateRequest = await req.json();
    const {
        rootPath,
        patterns = ['\\.tsx?$', '\\.jsx?$', '\\.py$'],
        excludePatterns = [],
        maxConcurrent = 5,
        outputPath,
    } = body;

    // output file path
    const mdPath = outputPath || path.join(rootPath, 'DOCS.md');

    // parse patterns
    const includeRegexes = parsePatterns(patterns);
    const excludeRegexes = [
        ...DEFAULT_EXCLUDE_PATTERNS,
        ...parsePatterns(excludePatterns),
    ];

    // create SSE stream
    const encoder = new TextEncoder();
    const stream = new ReadableStream({
        async start(controller) {
            const sendEvent = (event: DocEvent) => {
                controller.enqueue(encoder.encode(encodeSSE(event)));
            };

            const state: DocTreeState = {
                nodes: [],
                status: 'scanning',
            };

            try {
                // STEP 1: scan files
                sendEvent({ type: 'scan:start', pattern: patterns.join(', ') });
                const files = await scanDirectory(rootPath, includeRegexes, excludeRegexes);

                for (const file of files) {
                    sendEvent({ type: 'scan:file', filePath: file.relativePath });
                }
                sendEvent({ type: 'scan:complete', fileCount: files.length });

                if (files.length === 0) {
                    sendEvent({ type: 'execution:error', error: 'No files matched patterns' });
                    controller.close();
                    return;
                }

                // STEP 2: distribute files to subagent batches
                // each subagent processes exactly ONE file
                state.status = 'documenting';
                const batches = distributeFilesToSubagents(files, maxConcurrent);
                const allDocs: Array<{ path: string; doc: string }> = [];

                for (let batchIdx = 0; batchIdx < batches.length; batchIdx++) {
                    const batch = batches[batchIdx];

                    // create nodes for this batch
                    const batchNodes: DocNode[] = batch.map((file) => ({
                        id: nanoid(8),
                        filePath: file.relativePath,
                        status: 'pending' as const,
                        content: file.content,
                        language: file.language,
                        lineCount: file.lineCount,
                        startedAt: Date.now(),
                    }));

                    // emit node creation events
                    for (const node of batchNodes) {
                        sendEvent({ type: 'node:created', node });
                        sendEvent({ type: 'node:status', nodeId: node.id, status: 'documenting' });
                        state.nodes.push(node);
                    }

                    // STEP 3: parallel LLM calls for batch
                    // each subagent gets exactly 1 file
                    const promises = batch.map(async (file, idx) => {
                        const node = batchNodes[idx];
                        const prompt = buildFileDocPrompt(
                            file.relativePath,
                            file.content,
                            file.language
                        );

                        try {
                            const result = await generateText({
                                model: anthropic('claude-sonnet-4-20250514'),
                                system: DOC_AGENT_SYSTEM_PROMPT,
                                prompt,
                                maxOutputTokens: 2048,
                            });

                            // update node
                            node.documentation = result.text;
                            node.status = 'completed';
                            node.completedAt = Date.now();

                            sendEvent({
                                type: 'node:documented',
                                nodeId: node.id,
                                documentation: result.text,
                            });
                            sendEvent({ type: 'node:status', nodeId: node.id, status: 'completed' });

                            return { path: file.relativePath, doc: result.text };
                        } catch (err) {
                            const errorMsg = err instanceof Error ? err.message : String(err);
                            node.status = 'error';
                            node.error = errorMsg;
                            sendEvent({ type: 'node:error', nodeId: node.id, error: errorMsg });
                            return { path: file.relativePath, doc: `ERROR: ${errorMsg}` };
                        }
                    });

                    // wait for batch to complete
                    const batchResults = await Promise.all(promises);
                    allDocs.push(...batchResults);
                }

                // STEP 4: aggregate into project summary
                sendEvent({ type: 'summary:start' });
                const fileTree = generateFileTree(files);
                const summaryPrompt = buildProjectSummaryPrompt(fileTree, allDocs);

                const summaryResult = await generateText({
                    model: anthropic('claude-sonnet-4-20250514'),
                    system: PROJECT_SUMMARY_PROMPT,
                    prompt: summaryPrompt,
                    maxOutputTokens: 4096,
                });

                state.projectSummary = summaryResult.text;

                // STEP 5: write markdown file
                const markdown = buildMarkdown(summaryResult.text, allDocs, fileTree);
                await fs.writeFile(mdPath, markdown, 'utf-8');

                state.status = 'completed';
                sendEvent({ type: 'summary:complete', summary: `Docs written to: ${mdPath}` });
                sendEvent({ type: 'execution:complete', result: state });
            } catch (error) {
                const errorMsg = error instanceof Error ? error.message : String(error);
                state.status = 'error';
                state.error = errorMsg;
                sendEvent({ type: 'execution:error', error: errorMsg });
            }

            controller.close();
        },
    });

    return new Response(stream, {
        headers: {
            'Content-Type': 'text/event-stream',
            'Cache-Control': 'no-cache',
            Connection: 'keep-alive',
        },
    });
}
